---
title: "Context"
---


AI Voice Agents maintain conversation context across multiple turns, enabling natural multi-turn conversations.

## What is Context?

Context is the conversation history and information that your agent remembers:

- **Conversation History** - All messages in the current session
- **Tool Results** - Results from function calls
- **User Preferences** - Information about the user
- **Session State** - Current conversation state

## Multi-Turn Conversations

Agents automatically maintain context across conversation turns:

<CodeGroup>
```python
# Turn 1
User: "What's the weather in London?"
Agent: "The weather in London is cloudy, 15°C."

# Turn 2 (agent remembers London from previous turn)
User: "What about tomorrow?"
Agent: "Tomorrow in London will be sunny, 18°C."

# Turn 3 (agent remembers the conversation)
User: "And the day after?"
Agent: "The day after tomorrow in London will be partly cloudy, 16°C."
```
</CodeGroup>

## How Context Works

### Session-Based Context

Each WebSocket connection creates a new session with its own context:

- **Session ID** - Unique identifier for each conversation
- **Message History** - All messages in the session
- **Tool Call History** - All tool calls and results
- **User Metadata** - Optional user information

### Context Management

The agent automatically manages context:

1. **Stores messages** - All user messages and agent responses
2. **Includes tool results** - Tool execution results are added to context
3. **Maintains history** - Full conversation history is available to the LLM
4. **Manages session** - Each session has isolated context

## Context in Tool Calls

Tool results are automatically included in context:

<CodeGroup>
```python
# User asks a question
User: "What's the weather in London?"

# Agent calls tool
Agent calls: get_weather(location="London")
Tool returns: "Weather in London: cloudy, 15°C"

# Tool result is added to context
# Agent uses context to respond
Agent: "The weather in London is cloudy, 15°C."

# In next turn, agent remembers the tool call
User: "What about tomorrow?"
# Agent can use previous context to understand "tomorrow" and "London"
```
</CodeGroup>

## Session Management

### Creating Sessions

Sessions are created automatically when clients connect:

<CodeGroup>
```python
# Server side - each connection gets a session
from kuralit.server.websocket_server import create_app

app = create_app(
    api_key_validator=lambda key: key == "demo-api-key",
    agent_session=agent,
)
# Each WebSocket connection = new session
```
</CodeGroup>

### Client Side

<CodeGroup>
```dart
// Flutter client
final sessionId = Kuralit.generateSessionId();
await Kuralit.connect();
Kuralit.sendText(sessionId, 'Hello!');
// All messages with same sessionId share context
```
</CodeGroup>

## Best Practices

### Context Length

- **Keep conversations focused** - Long conversations may exceed context limits
- **Use tools effectively** - Tools can help manage context by storing information
- **Clear session boundaries** - Start new sessions for new topics

### Context Quality

- **Clear user messages** - Help the agent understand intent
- **Relevant tool results** - Tools should return useful information
- **Consistent terminology** - Use consistent terms throughout conversation

## Next Steps

- [Creating Agents →](/basics/agents/creating-agents) - Learn how to create agents
- [Instructions →](/basics/agents/instructions) - Write effective instructions
- [Sessions →](/basics/sessions) - Learn about session management

